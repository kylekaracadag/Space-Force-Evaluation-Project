@inject IUserData userData
@inject IRequestsData requestsData
@inject IEvaluationsData evaluationsData
@inject ISnackbar Snackbar
@inject ITeamsData teamsData
@inject IADCONData ADCONData

<head>
    <style>
    </style>
</head>

<MudDialog Style="border-radius: 15px;
            background: #E7F1FF;
            box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.25), 0px 4px 4px rgba(0, 0, 0, 0.25), 0px 4px 4px rgba(0, 0, 0, 0.25); width:65%; min-width:590px;">
    <DialogContent> 
        <MudGrid Spacing="0">
            <MudItem xs=@rightPanelSize>
                <div>
                    <p class="mb-4"><b>User</b>: @selectedUser.firstName</p>
                    <p><b>Direct Superior</b>: @superiorName</p>
                    <p><b>Rank:</b> @selectedUser.rank</p>
                    <p><b>Job:</b> @selectedUser.job</p>
                    <p><b>Role:</b> @selectedUser.role</p>
                </div>
            </MudItem>

            <MudItem xs="6">
                <div style=" height: 100%;width: 100%; border-left: solid 1px; padding-left: 15px">

                    @if (!isSameUser)
                    {
                        /*
                        TODO: use this if we have indirect ADCON support
                        @if (hasGreatORequalRole && !hasDirectADCON && !hasIndirectADCON)
                        {
                            <MudButton Disabled="@(superior == null || processingADCONRequest)" OnClick="() => requestADCONOverUser()">Request ADCON</MudButton>
                        }
                        */

                        @if (hasGreatORequalRole && !hasDirectADCON)
                        {
                            <MudButton Disabled="@(superior == null || processingADCONRequest)" OnClick="() => requestADCONOverUser()">Request ADCON</MudButton>
                        }

                        @if ((!hasDirectADCON && hasIndirectADCON) || (currentUser.role == "HQ" && !hasDirectADCON))
                        {
                            <MudButton Disabled="@(processingADCONRequest)" OnClick="() => takeADCON(selectedUser)">Take ADCON</MudButton>
                        }

                        @if (currentUser.role != "HQ" && !selectedIsEvaluatorOfCurrent)
                        {
                            <MudButton Disabled="@(selectedIsEvaluatorOfCurrent || processingEvaluatorRequest)"
                                OnClick="() => makeSelfAssignedEvaluatorRequest()">Request to be your evaluator</MudButton>
                        }

                        @if (selectedIsSelfAssignedEvaluator)
                        {
                            <MudButton Disabled="@(processingEvaluatorRequest)"
                                OnClick="() => removeSelfAssignedEvaluator()">Remove from your evaluators</MudButton>
                        }



                        // TODO: update to account for supervisors
                        // A simple way to get around this if statement would be to check if the user leads any teams
                        // in addition to checking for direct/indirect ADCON
                        @if ((hasDirectADCON || hasIndirectADCON) && (currentUser.role == "Commander" || currentUser.role == "HQ")) 
                        {
                            <MudSelect @bind-Value="selectedTeam" Label="Assign To Team" Placeholder="Select team" AdornmentColor="Color.Primary">
                                <MudSelectItem T="@TeamsModel" Value="@null" Disabled="true">Your Teams</MudSelectItem>
               
                                @if(currentUserTeams != null)
                                {
                                    @foreach(var team in currentUserTeams)
                                    {
                                        <MudSelectItem Disabled="@processingOPCONRequest" T="@TeamsModel" Value="@team">@team.name</MudSelectItem>
                                    }
                                }
                                
                            </MudSelect>

                            <MudButton OnClick="() => onOPCONAssignment(selectedUser.userID, selectedTeam.ObjectId)">Confirm Team Assignment</MudButton>
                        }
                        
                        // TODO: update to account for supervisors
                        else if (hasGreatORequalRole)
                        {
                            <MudSelect @bind-Value="selectedTeam" Label="Request Team Outsource" Placeholder="Select team" AdornmentColor="Color.Primary">
                                <MudSelectItem T="@TeamsModel" Value="@null" Disabled="true">Your Teams</MudSelectItem>

                                @if (currentUserTeams != null)
                                {
                                    @foreach (var team in currentUserTeams)
                                    {
                                        <MudSelectItem T="@TeamsModel" Value="@team">@team.name</MudSelectItem>
                                    }
                                }

                            </MudSelect>

                            <MudButton OnClick="() => makeOPCONOutsourceRequest()">Request Team Outsource</MudButton>
                        }
                    }

            

                    @if ((currentUser.role == "HQ" || (currentUser.role == "Commander" && selectedUser.role == "Member")) && !isSameUser)
                    {
                        <MudSelect @bind-Value="roleAssignmentValue" Label="Update Role" Placeholder="Select role" AdornmentColor="Color.Primary">
                            <MudSelectItem Value="@("N/A")" Disabled="true">Roles</MudSelectItem>
                            @if(currentUser.role == "HQ") 
                            {
                                <MudSelectItem Value="@("Commander")">Commander</MudSelectItem>
                                <MudSelectItem Value="@("Supervisor")">Supervisor</MudSelectItem>
                                <MudSelectItem Value="@("Member")">Member</MudSelectItem>
                            }
                            else
                            {
                                <MudSelectItem Value="@("Supervisor")">Supervisor</MudSelectItem>
                            }
                        </MudSelect>

                        <MudButton 
                            OnClick="() => updateSelectedUserRole(roleAssignmentValue)">Confirm Role @roleAssignmentPrompt</MudButton>
                    }
                </div>
            </MudItem>

            <MudItem xs="12">

                @if (hasDirectADCON)
                {
                    <div style=" height: 100%;width: 100%; border-top: solid 1px; padding-top: 15px">
                        @if(superiorAssignedEvaluators != null && superiorAssignedEvaluators.Count > 0)
                        {
                            <MudTable Items="@superiorAssignedEvaluators" Hover="false">
                                <ToolBarContent>
                                    <MudText>Superior Assigned Evaluators</MudText>
                                    <MudSpacer />
                                </ToolBarContent>
                                <HeaderContent>
                                    <MudTh>User</MudTh>
                                    <MudTh>Email</MudTh>
                                </HeaderContent>
                                <RowTemplate>
                                    <MudTd>@context.firstName</MudTd>
                                    <MudTd>@context.email</MudTd>
                                    <MudTd><MudButton OnClick="() => onRemoveSuperiorAssignedEvaluator(context.userID, selectedUser.userID)">Remove evaluator</MudButton></MudTd>
                                </RowTemplate>
                            </MudTable>
                        }
                    
                        <div>
                            <MudInput FullWidth="true" T="string" Placeholder="New evaluator's email" @bind-Value="superiorAssignedEvaluatorEmail"/>
                            <div>
                                <MudButton OnClick="() => makeSuperiorAssignedEvaluatorRequest()">Request to be @selectedUser.firstName's evaluator </MudButton>
                            </div>
                        </div>
                    </div>
                    
                }
            </MudItem>
        </MudGrid>
        
    </DialogContent>

    <DialogActions>
        <MudButton OnClick="Cancel">Close</MudButton> 
    </DialogActions>
</MudDialog>
@code {


    [CascadingParameter] MudDialogInstance MudDialog { get; set; }
    [Parameter] public UserModel selectedUser { get; set; }
    [Parameter] public UserModel currentUser { get; set; }
    [Parameter] public List<TeamsModel> currentUserTeams { get; set; }

    List<UserModel> superiorAssignedEvaluators = new List<UserModel>();

    TeamsModel selectedTeam;

    int rightPanelSize;
    bool hasDirectADCON = false;
    bool hasIndirectADCON = false;
    bool hasOPCON = false;
    bool hasGreatORequalRole = false;
    bool isSameUser = false;
    bool selectedIsEvaluatorOfCurrent = false;
    bool selectedIsSelfAssignedEvaluator = false;
    bool selectedIsSuperiorAssignedEvaluator = false;
    bool selectedUserHasUnassignedRole;

    bool processingADCONRequest = false;
    bool processingOPCONRequest = false;
    bool processingEvaluatorRequest = false;
    bool processingSuperiorEvaluationRequest = false;

    String roleAssignmentValue = "";
    String roleAssignmentPrompt = "";
    String superiorName = "";
    UserModel superior;
    String superiorAssignedEvaluatorEmail = ""; 


    void Submit() => MudDialog.Close(DialogResult.Ok(true));
    void Cancel() => MudDialog.Cancel();

    async Task takeADCON(UserModel subordinate)
    {
        processingADCONRequest = true;

        bool ADCONCheck = await ADCONData.hasDirectADCONOverUser(subordinate, currentUser);

        if(ADCONCheck == true)
        {
            Snackbar.Add("ERROR: user already has direct ADCON", Severity.Error);
            return;
        }

        bool result = await ADCONData.ADCONTransfer(currentUser.userID, subordinate.userID);

        if(result)
        {
            Snackbar.Add("Successfully took ADCON. Changes will show after you close the dialog.", Severity.Success);
        }
        else
        {
            Snackbar.Add("ERROR: user already has direct ADCON", Severity.Error);
        }
        processingADCONRequest = true;
    }


    async Task requestADCONOverUser()
    {
        processingADCONRequest = true;
        RequestsModel newADCONTransferRequest = new RequestsModel();
        newADCONTransferRequest.requestRespondents = new List<string>();
        newADCONTransferRequest.requestInitiator = currentUser.userID;

        String selectedUsers_superiorID = (await ADCONData.GetADCONBySubordinate(selectedUser.userID))?.superiorID;

        UserModel firstUserForHandshake = (await ADCONData.GetClosestCommander(selectedUsers_superiorID)); 
        UserModel secondUserForHandshake = (await ADCONData.GetClosestCommander(currentUser.userID)); 


        String secondUserForHandshakes_superior = (await ADCONData.GetADCONBySubordinate(secondUserForHandshake.userID))?.superiorID;

        if(firstUserForHandshake.userID == secondUserForHandshake.userID)
        {
            newADCONTransferRequest.requestRecipiants = new List<String> { secondUserForHandshake.userID };
        }
        else if(firstUserForHandshake.userID == secondUserForHandshakes_superior)
        {
            // if the current user is trying to ask for ADCON of a peer,then only need their direct superior.
            newADCONTransferRequest.requestRecipiants = new List<String> { firstUserForHandshake.userID };
        }
        else if (await ADCONData.hasDirectADCONOverUser(secondUserForHandshake, firstUserForHandshake)) 
        {
            // only need second user
            newADCONTransferRequest.requestRecipiants = new List<String> { secondUserForHandshake.userID };
        }
        else if (await ADCONData.hasDirectADCONOverUser(firstUserForHandshake, secondUserForHandshake)) 
        {
            // only need first user
            newADCONTransferRequest.requestRecipiants = new List<String> { firstUserForHandshake.userID };
        }
        else if( await ADCONData.hasIndirectADCONOverUser(secondUserForHandshake, firstUserForHandshake)) 
        {
            // only need second user
            newADCONTransferRequest.requestRecipiants = new List<String> { secondUserForHandshake.userID };
        }
        else if(await ADCONData.hasIndirectADCONOverUser(firstUserForHandshake, secondUserForHandshake))
        {
            // only need first user
            newADCONTransferRequest.requestRecipiants = new List<String> { firstUserForHandshake.userID };
        }
        else if (secondUserForHandshake.userID == newADCONTransferRequest.requestInitiator)
        {
            // no need second user for handshake is also sender, so only need permission from second user
            newADCONTransferRequest.requestRecipiants = new List<String> { firstUserForHandshake.userID };
        }
        else 
        {
            // need both users
            newADCONTransferRequest.requestRecipiants = new List<String> { firstUserForHandshake.userID, secondUserForHandshake.userID };
        }

        newADCONTransferRequest.values = new List<String> { selectedUser.userID };
        newADCONTransferRequest.type = "ADCON transfer request";
        newADCONTransferRequest.status = "Pending";

        if (await requestsData.CheckIfRequestExist(newADCONTransferRequest))
        {
            Snackbar.Add("ERROR: request alread exist", Severity.Error);
        }
        else
        {
            Snackbar.Add("Request sent", Severity.Success);
            await requestsData.CreateRequests(newADCONTransferRequest);
        }
        processingADCONRequest = false;

    }


    async Task<bool> isUserSelfAssignedEvaluator(UserModel user, UserModel potentialEvaluator)
    {
        EvaluationsModel evaluation = await evaluationsData.GetByEvaluatorAndUserBeingEvaluated(potentialEvaluator.userID, user.userID);
        return ((evaluation != null) && (evaluation.superiorAssigned == false));
    }


    async Task<bool> isUserSuperiorAssignedEvaluator(UserModel user, UserModel potentialEvaluator)
    {
        EvaluationsModel evaluation = await evaluationsData.GetByEvaluatorAndUserBeingEvaluated(potentialEvaluator.userID, user.userID);
        return ((evaluation != null) && (evaluation.superiorAssigned == true));
    }

    async Task makeSuperiorAssignedEvaluatorRequest()
    {
        processingSuperiorEvaluationRequest = true;
        UserModel potentialEvaluator = await userData.GetUserByEmail(superiorAssignedEvaluatorEmail);

        var superiorAssignedEvaluatorIDs = await evaluationsData.GetAllSuperiorAssignedEvaluatorsIDs(selectedUser.userID);
        if (superiorAssignedEvaluatorIDs != null && superiorAssignedEvaluatorIDs.Count > 3) // TODO: change the 3 to a variable, not a hard coded number
        {
            Snackbar.Add($"ERROR: user has max number of superior assigned evaluators.", Severity.Error);
        }
        else if(potentialEvaluator == null)
        {
            Snackbar.Add($"ERROR: user with email ({superiorAssignedEvaluatorEmail}) not found", Severity.Error);
        }
        else if (await isUserSuperiorAssignedEvaluator(selectedUser, potentialEvaluator))
        {
            Snackbar.Add($"ERROR: {potentialEvaluator.firstName} is already a superior assigned evaluator", Severity.Error);
        }
        else if(await isUserSelfAssignedEvaluator(selectedUser, potentialEvaluator))
        {
            Snackbar.Add($"ERROR: {potentialEvaluator.firstName} was already assigned by {selectedUser.firstName} to be an evaluator", Severity.Error);
        }
        else
        {
            // TODO: update after Ethan sends new model. 
            RequestsModel newEvaluationAssignmentRequest = new RequestsModel();
            newEvaluationAssignmentRequest.requestInitiator = currentUser.userID;
            newEvaluationAssignmentRequest.requestRespondents = new List<string>();
            newEvaluationAssignmentRequest.requestRecipiants = new List<String> { potentialEvaluator.userID, null };

            newEvaluationAssignmentRequest.values = new List<String>{ selectedUser.userID };
            newEvaluationAssignmentRequest.type = "SuperiorAssignedEvaluationRequest";
            newEvaluationAssignmentRequest.status = "Pending";

            if (await requestsData.CheckIfRequestExist(newEvaluationAssignmentRequest))
            {
                Snackbar.Add("ERROR: request alread exist", Severity.Error);
            }
            else
            {
                Snackbar.Add("Request sent", Severity.Success);
                await requestsData.CreateRequests(newEvaluationAssignmentRequest);
            }
        }
        processingSuperiorEvaluationRequest = false;
    }


    async Task makeSelfAssignedEvaluatorRequest()
    {
        processingEvaluatorRequest = true;
        RequestsModel newEvaluationAssignmentRequest = new RequestsModel();
        newEvaluationAssignmentRequest.requestInitiator = currentUser.userID;
        newEvaluationAssignmentRequest.requestRespondents = new List<string>();
        String curentUsers_superior = (await ADCONData.GetADCONBySubordinate(currentUser.userID))?.superiorID;
        newEvaluationAssignmentRequest.requestRecipiants = new List<String> { curentUsers_superior, selectedUser.userID };

        if(newEvaluationAssignmentRequest.values == null)
        {
            newEvaluationAssignmentRequest.values = new List<string>();
        }
        newEvaluationAssignmentRequest.values.Add(selectedUser.userID);
        newEvaluationAssignmentRequest.values.Add(currentUser.userID);

        newEvaluationAssignmentRequest.type = "EvaluationAssignmentRequest";
        newEvaluationAssignmentRequest.status = "Pending";

        if (await requestsData.CheckIfRequestExist(newEvaluationAssignmentRequest))
        {
            Snackbar.Add("ERROR: request alread exist", Severity.Error);
        }
        else
        {
            Snackbar.Add("Request sent", Severity.Success);
            await requestsData.CreateRequests(newEvaluationAssignmentRequest);
        }
        processingEvaluatorRequest = false;
    }

    async Task removeSelfAssignedEvaluator()
    {

        // Task RemoveEvaluation(string ObjectID)
        var evaluation = await evaluationsData.GetByEvaluatorAndUserBeingEvaluated(selectedUser.userID, currentUser.userID);
        await evaluationsData.RemoveEvaluation(evaluation);
        Snackbar.Add("Removed as evaluator. Refresh to see changes", Severity.Success);
        processingEvaluatorRequest = true;
    }

    async Task onRemoveSuperiorAssignedEvaluator(string evaluatorID, string userID)
    {
        var evaluation = await evaluationsData.GetByEvaluatorAndUserBeingEvaluated(evaluatorID, userID);
        await evaluationsData.RemoveEvaluation(evaluation);
        Snackbar.Add("Removed as evaluator. Refresh to see changes", Severity.Success);
        processingEvaluatorRequest = true;
    }

    IDictionary<string, int> roles = new Dictionary<string, int>() {
        { "HQ", 1 },
        { "Commander", 2 },
        { "Supervisor", 3 },
        { "Member", 4 },
    };

    // TODO: move this to data layer and rename to compareRoles
    bool isSuperiorToSelectedUser(string selectedUserRole)
    {
        if (selectedUserRole == "HQ" || selectedUserRole == "Commander" || selectedUserRole == "Supervisor" || selectedUserRole == "Member")
        {
            if (currentUser.role == "HQ" || currentUser.role == "Commander" || currentUser.role == "Supervisor" || currentUser.role == "Member")
            {
                if (roles[selectedUserRole] >= roles[currentUser.role] && currentUser.role != "Member")
                {
                    return true;
                }
            }
        }

        return false;
    }

    // TODO: move this to data layer
    bool doesUserHaveUnassignedRole(UserModel selectedUser)
    {
        return selectedUser.role == null;
    }

    // TODO: move this to data layer
    async Task updateSelectedUserRole(String newRole)
    {
        selectedUser.role = newRole;
        await userData.UpdateUser(selectedUser);
    }


    async Task<bool> assignOPCON(string userID, string teamID)
    {
        TeamsModel team = await teamsData.GetTeam(teamID);

        if(team.members == null) team.members = new List<string>();

        if (team.members.Contains(userID) == false)
        {
            UserModel user = await userData.GetUser(userID);

            if(user.teamIDs.Contains(team.ObjectId) == true)
            {
                return false;
            }

            team.members.Add(userID);
            user.teamIDs.Add(team.ObjectId);
            await userData.UpdateUser(user);
            await teamsData.UpdateTeam(team);
            return true;
        }
        return false;
    }

    async Task onOPCONAssignment(string userID, string teamID)
    {

        bool result = await assignOPCON(userID, teamID);

        if(result)
        {
            Snackbar.Add("Sucecssfully assigned OPCON", Severity.Success);
        }
        else
        {
            Snackbar.Add("ERROR: unable to assign OPCON", Severity.Error);
        }
    }


    async Task makeOPCONOutsourceRequest()
    {

        processingOPCONRequest = true;
        if (selectedTeam == null)
        {
            Snackbar.Add("ERROR: must select a valid team", Severity.Error);
        }

        RequestsModel newOPCONOutsourceRequest = new RequestsModel();

        String selectedUsers_superior = (await ADCONData.GetADCONBySubordinate(selectedUser.userID))?.superiorID;
        UserModel closestSuperCommanderTo_SelectedUser = await ADCONData.GetClosestCommander(selectedUsers_superior);

        // If current user's role is Commander/HQ, then we only need the closest superior commander to the selected user to approve
        if(currentUser.role == "Commander")
        {
            newOPCONOutsourceRequest.requestRecipiants = new List<String>
            {
                closestSuperCommanderTo_SelectedUser.userID,
            };
        }
        else
        {
            UserModel secondRecipiant = await ADCONData.GetClosestCommander(selectedUsers_superior);
            UserModel closestSuperCommanderTo_CurrentUser = await ADCONData.GetClosestCommander(currentUser.userID);

            newOPCONOutsourceRequest.requestRecipiants = new List<String>
            {
                closestSuperCommanderTo_SelectedUser.userID,
                closestSuperCommanderTo_CurrentUser.userID
            };
        }

        
        //TODO: update to account for supervisors being team leaders
        //in the event that a supervisor is a team leader, then you need to have both the 
        //closest commander to the team leader and the colest commander to the user being transfered 
        //approve of the requests. 
        
        //TODO: if the team leader is a Commander, then we simply just need to ask the closest commander of the
        //supervisor for permission. 

        newOPCONOutsourceRequest.requestInitiator = selectedTeam.leader;
        newOPCONOutsourceRequest.requestRespondents = new List<string>();
        newOPCONOutsourceRequest.values = new List<String> { selectedUser.userID, selectedTeam.ObjectId };
        newOPCONOutsourceRequest.type = "OPCONOutsourceRequest";
        newOPCONOutsourceRequest.status = "Pending";


        if (await requestsData.CheckIfRequestExist(newOPCONOutsourceRequest))
        {
            Snackbar.Add("ERROR: request alread exist", Severity.Error);
        }
        else
        {
            await requestsData.CreateRequests(newOPCONOutsourceRequest);
            Snackbar.Add("Request sent", Severity.Success);

        }
        processingOPCONRequest = false;
    }


    public async Task<List<UserModel>> getSuperiorAssignedEvaluators(UserModel user)
    {
        var superiorAssignedEvaluatorIDs = await evaluationsData.GetAllSuperiorAssignedEvaluatorsIDs(user.userID);

        List<UserModel> superiorAssignedEvaluators = new List<UserModel>();

        if (superiorAssignedEvaluatorIDs != null)
        {
            foreach (var evaluatorID in superiorAssignedEvaluatorIDs)
            {
                superiorAssignedEvaluators.Add(await userData.GetUser(evaluatorID));
            }
        }

        return superiorAssignedEvaluators;
    }


    protected async override Task OnInitializedAsync()
    {
        isSameUser = selectedUser.userID == currentUser.userID;
        rightPanelSize = isSameUser ? 12 : 6;
        hasIndirectADCON = await ADCONData.hasIndirectADCONOverUser(selectedUser, currentUser);
        hasDirectADCON = await ADCONData.hasDirectADCONOverUser(selectedUser, currentUser);
        hasOPCON = false; // TODO: update to see if they have OPCON over the selected user

        var evaluationCheck = await evaluationsData.GetByEvaluatorAndUserBeingEvaluated(selectedUser.userID, currentUser.userID);
        selectedIsEvaluatorOfCurrent = (evaluationCheck != null);
        selectedIsSelfAssignedEvaluator = ((selectedIsEvaluatorOfCurrent == true) && (evaluationCheck.superiorAssigned == false));
        selectedIsSuperiorAssignedEvaluator = ((selectedIsEvaluatorOfCurrent == true) && (evaluationCheck.superiorAssigned == true));


        hasGreatORequalRole = isSuperiorToSelectedUser(selectedUser.role);
        selectedUserHasUnassignedRole = doesUserHaveUnassignedRole(selectedUser);


        String selectedUsers_superiorID = (await ADCONData.GetADCONBySubordinate(selectedUser.userID))?.superiorID;

        if (selectedUser.role == null)
        {
            roleAssignmentPrompt = "Assignment";
        }
        else
        {
            roleAssignmentPrompt = "Change";
        }

        if (selectedUsers_superiorID == null || selectedUsers_superiorID == "")
        {
            superiorName = "None";
        }
        else
        {
            superior = await userData.GetUser(selectedUsers_superiorID);
            superiorName = superior?.firstName;
        }

        superiorAssignedEvaluators = await getSuperiorAssignedEvaluators(selectedUser);


        //await userData.EmptyAllSupordinatesAndSuperiorsList();
        //await userData.EmptyAllTeamIDs();
        //await teamsData.RemoveAllTeams();
        //await requestsData.RemoveAllRequests();
        //await ADCONData.RemoveAllADCON();
        //await evaluationsData.RemoveAllEvaluations();

        //UserModel testUser = await userData.GetUserFromFirstName("Angela");
        //testUser.firstName = "Matthew";
        //testUser.lastName = "Jones";
        //await userData.UpdateUser(testUser);
    }
}
