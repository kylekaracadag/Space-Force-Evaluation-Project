@inject IUserData userData
@inject IRequestsData requestsData
@inject ISnackbar Snackbar
@inject ITeamsData teamsData

<MudDialog>
    <DialogContent>
        <div>

            <p class="mb-4"><b>User</b>: @selectedUser.firstName</p>
            <p><b>Direct Superior</b>: @superiorName</p>
            <p><b>Rank:</b> @selectedUser.rank</p>
            <p><b>Job:</b> @selectedUser.job</p>
            <p><b>Role:</b> @selectedUser.role</p>
             
            @if ((hasDirectADCON || hasIndirectADCON) && !isSameUser)
            {
                <p>last daily survey taken: TODO</p>
                <p>last weekly survey taken: TODO</p>
                <p>last monthly survey taken: TODO</p>
                <p>Assign evaluator: TODO</p>
            }
        </div>

        <div>

            @if (!isSameUser)
            {
                @if (hasGreatORequalRole && !hasDirectADCON && !hasIndirectADCON)
                {
                    <MudButton Disabled="@(superior == null || processingADCONRequest)" OnClick="() => requestADCONOverUser()">Request ADCON</MudButton>
                    <MudButton Disabled="@(hasOPCON || processingOPCONRequest)" OnClick="() => Cancel()">Request OPCON</MudButton>
                }

                @if ((!hasDirectADCON && hasIndirectADCON) || (currentUser.role == "HQ" && !hasDirectADCON))
                {
                    <MudButton Disabled="@(processingADCONRequest)" OnClick="() => takeADCON(selectedUser)">Take ADCON</MudButton>
                }

                @if (currentUser.role != "HQ" && !selectedIsEvaluatorOfCurrent)
                {
                    <MudButton Disabled="@(selectedIsEvaluatorOfCurrent || processingEvaluatorRequest)"
                        OnClick="() => makeSelfAssignedEvaluatorRequest()">Request to be your evaluator</MudButton>
                }

                @if (selectedIsSelfAssignedEvaluator)
                {
                    <MudButton Disabled="@(processingEvaluatorRequest)"
                        OnClick="() => removeSelfAssignedEvaluator()">Remove from your evaluators</MudButton>
                }




                @if ((hasDirectADCON || hasIndirectADCON) && (currentUser.role == "Commander" || currentUser.role == "HQ")) // TODO: update to account for supervisors being team leaders if Roger says so
                {
                    <MudSelect @bind-Value="selectedTeam" Label="Assign To Team" Placeholder="Select team" AdornmentColor="Color.Primary">
                        <MudSelectItem T="@TeamsModel" Value="@null" Disabled="true">Your Teams</MudSelectItem>
               
                        @if(currentUserTeams != null)
                        {
                            @foreach(var team in currentUserTeams)
                            {
                                <MudSelectItem Disabled="@processingOPCONRequest" T="@TeamsModel" Value="@team">@team.name</MudSelectItem>
                            }
                        }
                                
                    </MudSelect>

                    <MudButton OnClick="() => onOPCONAssignment(selectedUser.userID, selectedTeam.ObjectId)">Confirm Team Assignment</MudButton>
                }
                <!-- TODO: ask if we need to send request even when there is indirect ADCON
                else if(hasIndirectADCON)
                {
                    OPCON Request here
                }-->
                else if (hasGreatORequalRole)
                {
                    <MudSelect @bind-Value="selectedTeam" Label="Request Team Outsource" Placeholder="Select team" AdornmentColor="Color.Primary">
                        <MudSelectItem T="@TeamsModel" Value="@null" Disabled="true">Your Teams</MudSelectItem>

                        @if (currentUserTeams != null)
                        {
                            @foreach (var team in currentUserTeams)
                            {
                                <MudSelectItem T="@TeamsModel" Value="@team">@team.name</MudSelectItem>

                            }
                        }

                    </MudSelect>

                    <MudButton OnClick="() => makeOPCONOutsourceRequest()">Request Team Outsource</MudButton>
                }

                @if (hasDirectADCON)
                {
                   <div>
                        <MudInput FullWidth="true" T="string" Placeholder="New evaluator's email" />
                        <div>
                            <MudButton>Request to be @selectedUser.firstName's evaluator </MudButton>
                        </div>
                    </div>
                    
                }
            }

            

            @if (currentUser.role == "HQ" && !isSameUser)
            {
                <MudSelect @bind-Value="roleAssignmentValue" Label="Update Role" Placeholder="Select role" AdornmentColor="Color.Primary">
                    <MudSelectItem Value="@("N/A")" Disabled="true">Roles</MudSelectItem>
                    <MudSelectItem Value="@("Commander")">Commander</MudSelectItem>
                    <MudSelectItem Value="@("Supervisor")">Supervisor</MudSelectItem>
                    <MudSelectItem Value="@("Member")">Member</MudSelectItem>
                </MudSelect>

                <MudButton 
                    OnClick="() => updateSelectedUserRole(roleAssignmentValue)">Confirm Role @roleAssignmentPrompt</MudButton>
            }
        </div>
        
    </DialogContent>

    <DialogActions>
        <MudButton OnClick="Cancel">Close</MudButton> 
    </DialogActions>
</MudDialog>
@code {


    [CascadingParameter] MudDialogInstance MudDialog { get; set; }
    [Parameter] public UserModel selectedUser { get; set; }
    [Parameter] public UserModel currentUser { get; set; }
    [Parameter] public List<TeamsModel> currentUserTeams { get; set; }

    TeamsModel selectedTeam;

    bool hasDirectADCON = false;
    bool hasIndirectADCON = false;
    bool hasOPCON = false;
    bool hasGreatORequalRole = false;
    bool isSameUser = false;
    bool selectedIsEvaluatorOfCurrent = false;
    bool selectedIsSelfAssignedEvaluator = false;
    bool selectedIsSuperiorAssignedEvaluator = false;
    bool selectedUserHasUnassignedRole;

    bool processingADCONRequest = false;
    bool processingOPCONRequest = false;
    bool processingEvaluatorRequest = false;

    String roleAssignmentValue = "";
    String roleAssignmentPrompt = "";
    String superiorName = "";
    UserModel superior;

    void Submit() => MudDialog.Close(DialogResult.Ok(true));
    void Cancel() => MudDialog.Cancel();

    async Task takeADCON(UserModel subordinate)
    {
        processingADCONRequest = true;
        foreach(var currentUsersSubordinate in currentUser?.subordinates)
        {
            if (currentUsersSubordinate == subordinate.userID)
            {
                Snackbar.Add("ERROR: user already has direct ADCON", Severity.Error);
                return;
            }

        }
        bool result = await userData.ADCONTransfer(currentUser.userID, subordinate.userID);

        if(result)
        {
            Snackbar.Add("Successfully took ADCON. Changes will show after you close the dialog.", Severity.Success);
        }
        else
        {
            Snackbar.Add("ERROR: user already has direct ADCON", Severity.Error);
        }
        processingADCONRequest = true;
    }


    async Task requestADCONOverUser()
    {
        processingADCONRequest = true;
        RequestsModel newADCONTransferRequest = new RequestsModel();
        newADCONTransferRequest.requestInitiator = currentUser.userID;

        UserModel firstUserForHandshake = (await userData.GetClosestCommander(selectedUser.superiors[0]));
        UserModel secondUserForHandshake = (await userData.GetClosestCommander(currentUser.userID));

        if(firstUserForHandshake.userID == secondUserForHandshake.superiors[0])
        {
            // if the current user is trying to ask for ADCON of a peer,then only need their direct superior.
            newADCONTransferRequest.requestTarget1 = firstUserForHandshake.userID;
        }
        else if(userData.hasDirectADCONOverUser(secondUserForHandshake, firstUserForHandshake))
        {
            // only need second user
            newADCONTransferRequest.requestTarget1 = secondUserForHandshake.userID;
        }
        else if(userData.hasDirectADCONOverUser(firstUserForHandshake, secondUserForHandshake))
        {
            // only need first user
            newADCONTransferRequest.requestTarget1 = firstUserForHandshake.userID;
        }
        else if( await userData.hasIndirectADCONOverUser(secondUserForHandshake, firstUserForHandshake))
        {
            // only need second user
            newADCONTransferRequest.requestTarget1 = secondUserForHandshake.userID;
        }
        else if(await userData.hasIndirectADCONOverUser(firstUserForHandshake, secondUserForHandshake))
        {
            // only need first user
            newADCONTransferRequest.requestTarget1 = firstUserForHandshake.userID;
        }
        else if (secondUserForHandshake.userID == newADCONTransferRequest.requestInitiator)
        {
            // no need second user for handshake is also sender, so only need permission from second user
            newADCONTransferRequest.requestTarget1 = firstUserForHandshake.userID;
        }
        else 
        {
            // need both users
            newADCONTransferRequest.requestTarget1 = firstUserForHandshake.userID;
            newADCONTransferRequest.requestTarget2 = secondUserForHandshake.userID;
        }

        newADCONTransferRequest.value = selectedUser.userID;
        newADCONTransferRequest.type = "ADCON transfer request";
        newADCONTransferRequest.status = "Pending";

        if (await requestsData.CheckIfRequestExist(newADCONTransferRequest))
        {
            Snackbar.Add("ERROR: request alread exist", Severity.Error);
        }
        else
        {
            Snackbar.Add("Request sent", Severity.Success);
            await requestsData.CreateRequests(newADCONTransferRequest);
        }
        processingADCONRequest = false;

    }


    async Task<bool> isUserSelfAssignedEvaluator(UserModel user, UserModel potentialEvaluator)
    {
        if(user.selfAssignedEvaluators == null)
        {
            return false;
        }

        return user.selfAssignedEvaluators.Contains(potentialEvaluator.userID);
    }


    async Task<bool> isUserSuperiorAssignedEvaluator(UserModel user, UserModel potentialEvaluator)
    {
        if (user.superiorAssignedEvaluators == null)
        {
            return false;
        }

        return user.superiorAssignedEvaluators.Contains(potentialEvaluator.userID);
    }


    async Task makeSelfAssignedEvaluatorRequest()
    {
        processingEvaluatorRequest = true;
        RequestsModel newEvaluationAssignmentRequest = new RequestsModel();
        newEvaluationAssignmentRequest.requestInitiator = currentUser.userID;
        newEvaluationAssignmentRequest.requestTarget1 = selectedUser.userID;
        newEvaluationAssignmentRequest.requestTarget2 = currentUser.superiors[0];
        newEvaluationAssignmentRequest.value = currentUser.userID;
        newEvaluationAssignmentRequest.type = "EvaluationAssignmentRequest";
        newEvaluationAssignmentRequest.status = "Pending";

        if (await requestsData.CheckIfRequestExist(newEvaluationAssignmentRequest))
        {
            Snackbar.Add("ERROR: request alread exist", Severity.Error);
        }
        else
        {
            Snackbar.Add("Request sent", Severity.Success);
            await requestsData.CreateRequests(newEvaluationAssignmentRequest);
        }
        processingEvaluatorRequest = false;
    }

    async Task removeSelfAssignedEvaluator()
    {
        await userData.removeSelfAssignedEvaluatorFromUser(selectedUser.userID, currentUser.userID);
        Snackbar.Add("Removed as evaluator. Refresh to see changes", Severity.Success);
        processingEvaluatorRequest = true;
    }

    IDictionary<string, int> roles = new Dictionary<string, int>() {
        { "HQ", 1 },
        { "Commander", 2 },
        { "Supervisor", 3 },
        { "Member", 4 },
    };

    // TODO: move this to data layer and rename to compareRoles
    bool isSuperiorToSelectedUser(string selectedUserRole)
    {
        if (selectedUserRole == "HQ" || selectedUserRole == "Commander" || selectedUserRole == "Supervisor" || selectedUserRole == "Member")
        {
            if (currentUser.role == "HQ" || currentUser.role == "Commander" || currentUser.role == "Supervisor" || currentUser.role == "Member")
            {
                if (roles[selectedUserRole] >= roles[currentUser.role] && currentUser.role != "Member")
                {
                    return true;
                }
            }
        }

        return false;
    }

    // TODO: move this to data layer
    bool doesUserHaveUnassignedRole(UserModel selectedUser)
    {
        return selectedUser.role == null;
    }

    // TODO: move this to data layer
    async Task updateSelectedUserRole(String newRole)
    {
        selectedUser.role = newRole;
        await userData.UpdateUser(selectedUser);
    }


    async Task<bool> assignOPCON(string userID, string teamID)
    {
        TeamsModel team = await teamsData.GetTeam(teamID);

        if(team.members == null) team.members = new List<string>();

        if (team.members.Contains(userID) == false)
        {
            UserModel user = await userData.GetUser(userID);

            if(user.teamIDs.Contains(team.ObjectId) == true)
            {
                return false;
            }

            team.members.Add(userID);
            user.teamIDs.Add(team.ObjectId);
            await userData.UpdateUser(user);
            await teamsData.UpdateTeam(team);
            return true;
        }
        return false;
    }

    async Task onOPCONAssignment(string userID, string teamID)
    {

        bool result = await assignOPCON(userID, teamID);

        if(result)
        {
            Snackbar.Add("Sucecssfully assigned OPCON", Severity.Success);
        }
        else
        {
            Snackbar.Add("ERROR: unable to assign OPCON", Severity.Error);
        }
    }


    async Task makeOPCONOutsourceRequest()
    {

        processingOPCONRequest = true;
        if (selectedTeam == null)
        {
            Snackbar.Add("ERROR: must select a valid team", Severity.Error);
        }
        RequestsModel newOPCONOutsourceRequest = new RequestsModel();
        newOPCONOutsourceRequest.requestTarget1 = selectedUser.superiors[0];
        newOPCONOutsourceRequest.requestTarget2 = selectedTeam.ObjectId; // TODO: update to account for supervisors being team leaders if Roger says so
        newOPCONOutsourceRequest.requestInitiator = selectedTeam.leader;
        newOPCONOutsourceRequest.value = selectedUser.userID;
        newOPCONOutsourceRequest.type = "OPCONOutsourceRequest";
        newOPCONOutsourceRequest.status = "Pending";


        if (await requestsData.CheckIfRequestExist(newOPCONOutsourceRequest))
        {
            Snackbar.Add("ERROR: request alread exist", Severity.Error);
        }
        else
        {
            await requestsData.CreateRequests(newOPCONOutsourceRequest);
            Snackbar.Add("Request sent", Severity.Success);

        }
        processingOPCONRequest = false;
    }


    protected async override Task OnInitializedAsync()
    {
        hasIndirectADCON = await userData.hasIndirectADCONOverUser(selectedUser, currentUser);
        hasDirectADCON = userData.hasDirectADCONOverUser(selectedUser, currentUser);
        hasOPCON = false; // TODO: update to see if they have OPCON over the selected user

        selectedIsSelfAssignedEvaluator = currentUser.selfAssignedEvaluators != null ? currentUser.selfAssignedEvaluators.Contains(selectedUser.userID) : false;
        selectedIsSuperiorAssignedEvaluator = currentUser.superiorAssignedEvaluators != null ? currentUser.superiorAssignedEvaluators.Contains(selectedUser.userID) : false;
        selectedIsEvaluatorOfCurrent = selectedIsSelfAssignedEvaluator || selectedIsSuperiorAssignedEvaluator;

        hasGreatORequalRole = isSuperiorToSelectedUser(selectedUser.role);
        selectedUserHasUnassignedRole = doesUserHaveUnassignedRole(selectedUser);
        isSameUser = selectedUser.userID == currentUser.userID;

        if (selectedUser.role == null)
        {
            roleAssignmentPrompt = "Assignment";
        }
        else
        {
            roleAssignmentPrompt = "Change";
        }

        if (selectedUser.superiors == null)
        {
            superiorName = "None";
        }
        else
        {
            if(selectedUser.superiors.Count > 0)
            {
                superior = await userData.GetUser(selectedUser?.superiors[0]);
                superiorName = superior?.firstName;
            }
            else
            {
                superiorName = "None";
            }

        }

        //await userData.EmptyAllSupordinatesAndSuperiorsList();
        // await requestsData.RemoveAllRequests();

        //currentUser.subordinates.Remove(selectedUser.userID);
        //await userData.UpdateUser(currentUser);

        //await userData.EmptyAllTeamIDs();
        //await teamsData.RemoveAllTeams();

        //await requestsData.RemoveAllRequestsOfType("OPCONOutsourceRequest");
    }
}
