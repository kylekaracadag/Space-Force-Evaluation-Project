@inject IUserData userData
@inject IRequestsData requestsData
@inject ISnackbar Snackbar
@inject ITeamsData teamsData
<head>
    <style>
    </style>
</head>

<MudDialog Style="border-radius: 15px;
            background: #E7F1FF;
            box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.25), 0px 4px 4px rgba(0, 0, 0, 0.25), 0px 4px 4px rgba(0, 0, 0, 0.25);">
    <DialogContent> 
        <div>

            <p class="mb-4"><b>User</b>: @selectedUser.firstName</p>
            <p><b>Direct Superior</b>: @superiorName</p>
            <p><b>Rank:</b> @selectedUser.rank</p>
            <p><b>Job:</b> @selectedUser.job</p>
            <p><b>Role:</b> @selectedUser.role</p>
             
            @if ((hasDirectADCON || hasIndirectADCON) && !isSameUser)
            {
                <p>last daily survey taken: TODO</p>
                <p>last weekly survey taken: TODO</p>
                <p>last monthly survey taken: TODO</p>
                <p>Assign evaluator: TODO</p>
            }
        </div>

        <div>

            @if (!isSameUser)
            {
                @if (hasGreatORequalRole && !hasDirectADCON && !hasIndirectADCON)
                {
                    <MudButton Disabled="@(superior == null || processingADCONRequest)" OnClick="() => requestADCONOverUser()">Request ADCON</MudButton>
                }

                @if ((!hasDirectADCON && hasIndirectADCON) || (currentUser.role == "HQ" && !hasDirectADCON))
                {
                    <MudButton Disabled="@(processingADCONRequest)" OnClick="() => takeADCON(selectedUser)">Take ADCON</MudButton>
                }

                @if (currentUser.role != "HQ" && !selectedIsEvaluatorOfCurrent)
                {
                    <MudButton Disabled="@(selectedIsEvaluatorOfCurrent || processingEvaluatorRequest)"
                        OnClick="() => makeSelfAssignedEvaluatorRequest()">Request to be your evaluator</MudButton>
                }

                @if (selectedIsSelfAssignedEvaluator)
                {
                    <MudButton Disabled="@(processingEvaluatorRequest)"
                        OnClick="() => removeSelfAssignedEvaluator()">Remove from your evaluators</MudButton>
                }




                @if ((hasDirectADCON || hasIndirectADCON) && (currentUser.role == "Commander" || currentUser.role == "HQ")) // TODO: update to account for supervisors being team leaders if Roger says so
                {
                    <MudSelect @bind-Value="selectedTeam" Label="Assign To Team" Placeholder="Select team" AdornmentColor="Color.Primary">
                        <MudSelectItem T="@TeamsModel" Value="@null" Disabled="true">Your Teams</MudSelectItem>
               
                        @if(currentUserTeams != null)
                        {
                            @foreach(var team in currentUserTeams)
                            {
                                <MudSelectItem Disabled="@processingOPCONRequest" T="@TeamsModel" Value="@team">@team.name</MudSelectItem>
                            }
                        }
                                
                    </MudSelect>

                    <MudButton OnClick="() => onOPCONAssignment(selectedUser.userID, selectedTeam.ObjectId)">Confirm Team Assignment</MudButton>
                }
                <!-- TODO: ask if we need to send request even when there is indirect ADCON
                else if(hasIndirectADCON)
                {
                    OPCON Request here
                }-->
                else if (hasGreatORequalRole)
                {
                    <MudSelect @bind-Value="selectedTeam" Label="Request Team Outsource" Placeholder="Select team" AdornmentColor="Color.Primary">
                        <MudSelectItem T="@TeamsModel" Value="@null" Disabled="true">Your Teams</MudSelectItem>

                        @if (currentUserTeams != null)
                        {
                            @foreach (var team in currentUserTeams)
                            {
                                <MudSelectItem T="@TeamsModel" Value="@team">@team.name</MudSelectItem>

                            }
                        }

                    </MudSelect>

                    <MudButton OnClick="() => makeOPCONOutsourceRequest()">Request Team Outsource</MudButton>
                }

                @if (hasDirectADCON)
                {
                    @if(superiorAssignedEvaluators != null && superiorAssignedEvaluators.Count > 0)
                    {
                        <MudTable Items="@superiorAssignedEvaluators" Hover="false">
                            <ToolBarContent>
                                <MudText>Superior Assigned Evaluators</MudText>
                                <MudSpacer />
                            </ToolBarContent>
                            <HeaderContent>
                                <MudTh>User</MudTh>
                                <MudTh>Email</MudTh>
                            </HeaderContent>
                            <RowTemplate>
                                <MudTd>@context.firstName</MudTd>
                                <MudTd>@context.email</MudTd>
                                <MudTd><MudButton OnClick="() => onRemoveSuperiorAssignedEvaluator(context.userID, selectedUser.userID)">Remove evaluator</MudButton></MudTd>
                            </RowTemplate>
                        </MudTable>
                    }
                    
                   <div>
                        <MudInput FullWidth="true" T="string" Placeholder="New evaluator's email" @bind-Value="superiorAssignedEvaluatorEmail"/>
                        <div>
                            <MudButton OnClick="() => makeSuperiorAssignedEvaluatorRequest()">Request to be @selectedUser.firstName's evaluator </MudButton>
                        </div>
                    </div>
                    
                }
            }

            

            @if ((currentUser.role == "HQ" || (currentUser.role == "Commander" && selectedUser.role == "Member")) && !isSameUser)
            {
                <MudSelect @bind-Value="roleAssignmentValue" Label="Update Role" Placeholder="Select role" AdornmentColor="Color.Primary">
                    <MudSelectItem Value="@("N/A")" Disabled="true">Roles</MudSelectItem>
                    @if(currentUser.role == "HQ") 
                    {
                        <MudSelectItem Value="@("Commander")">Commander</MudSelectItem>
                        <MudSelectItem Value="@("Supervisor")">Supervisor</MudSelectItem>
                        <MudSelectItem Value="@("Member")">Member</MudSelectItem>
                    }
                    else
                    {
                        <MudSelectItem Value="@("Supervisor")">Supervisor</MudSelectItem>
                    }
                </MudSelect>

                <MudButton 
                    OnClick="() => updateSelectedUserRole(roleAssignmentValue)">Confirm Role @roleAssignmentPrompt</MudButton>
            }
        </div>
        
    </DialogContent>

    <DialogActions>
        <MudButton OnClick="Cancel">Close</MudButton> 
    </DialogActions>
</MudDialog>
@code {


    [CascadingParameter] MudDialogInstance MudDialog { get; set; }
    [Parameter] public UserModel selectedUser { get; set; }
    [Parameter] public UserModel currentUser { get; set; }
    [Parameter] public List<TeamsModel> currentUserTeams { get; set; }

    List<UserModel> superiorAssignedEvaluators = new List<UserModel>();

    TeamsModel selectedTeam;

    bool hasDirectADCON = false;
    bool hasIndirectADCON = false;
    bool hasOPCON = false;
    bool hasGreatORequalRole = false;
    bool isSameUser = false;
    bool selectedIsEvaluatorOfCurrent = false;
    bool selectedIsSelfAssignedEvaluator = false;
    bool selectedIsSuperiorAssignedEvaluator = false;
    bool selectedUserHasUnassignedRole;

    bool processingADCONRequest = false;
    bool processingOPCONRequest = false;
    bool processingEvaluatorRequest = false;
    bool processingSuperiorEvaluationRequest = false;

    String roleAssignmentValue = "";
    String roleAssignmentPrompt = "";
    String superiorName = "";
    UserModel superior;
    String superiorAssignedEvaluatorEmail = ""; 


    void Submit() => MudDialog.Close(DialogResult.Ok(true));
    void Cancel() => MudDialog.Cancel();

    async Task takeADCON(UserModel subordinate)
    {
        processingADCONRequest = true;
        foreach(var currentUsersSubordinate in currentUser?.subordinates)
        {
            if (currentUsersSubordinate == subordinate.userID)
            {
                Snackbar.Add("ERROR: user already has direct ADCON", Severity.Error);
                return;
            }

        }
        bool result = await userData.ADCONTransfer(currentUser.userID, subordinate.userID);

        if(result)
        {
            Snackbar.Add("Successfully took ADCON. Changes will show after you close the dialog.", Severity.Success);
        }
        else
        {
            Snackbar.Add("ERROR: user already has direct ADCON", Severity.Error);
        }
        processingADCONRequest = true;
    }


    async Task requestADCONOverUser()
    {
        processingADCONRequest = true;
        RequestsModel newADCONTransferRequest = new RequestsModel();
        newADCONTransferRequest.requestInitiator = currentUser.userID;

        UserModel firstUserForHandshake = (await userData.GetClosestCommander(selectedUser.superiors[0]));
        UserModel secondUserForHandshake = (await userData.GetClosestCommander(currentUser.userID));

        if(firstUserForHandshake.userID == secondUserForHandshake.superiors[0])
        {
            // if the current user is trying to ask for ADCON of a peer,then only need their direct superior.
            newADCONTransferRequest.requestTarget1 = firstUserForHandshake.userID;
        }
        else if(userData.hasDirectADCONOverUser(secondUserForHandshake, firstUserForHandshake))
        {
            // only need second user
            newADCONTransferRequest.requestTarget1 = secondUserForHandshake.userID;
        }
        else if(userData.hasDirectADCONOverUser(firstUserForHandshake, secondUserForHandshake))
        {
            // only need first user
            newADCONTransferRequest.requestTarget1 = firstUserForHandshake.userID;
        }
        else if( await userData.hasIndirectADCONOverUser(secondUserForHandshake, firstUserForHandshake))
        {
            // only need second user
            newADCONTransferRequest.requestTarget1 = secondUserForHandshake.userID;
        }
        else if(await userData.hasIndirectADCONOverUser(firstUserForHandshake, secondUserForHandshake))
        {
            // only need first user
            newADCONTransferRequest.requestTarget1 = firstUserForHandshake.userID;
        }
        else if (secondUserForHandshake.userID == newADCONTransferRequest.requestInitiator)
        {
            // no need second user for handshake is also sender, so only need permission from second user
            newADCONTransferRequest.requestTarget1 = firstUserForHandshake.userID;
        }
        else 
        {
            // need both users
            newADCONTransferRequest.requestTarget1 = firstUserForHandshake.userID;
            newADCONTransferRequest.requestTarget2 = secondUserForHandshake.userID;
        }

        newADCONTransferRequest.value = selectedUser.userID;
        newADCONTransferRequest.type = "ADCON transfer request";
        newADCONTransferRequest.status = "Pending";

        if (await requestsData.CheckIfRequestExist(newADCONTransferRequest))
        {
            Snackbar.Add("ERROR: request alread exist", Severity.Error);
        }
        else
        {
            Snackbar.Add("Request sent", Severity.Success);
            await requestsData.CreateRequests(newADCONTransferRequest);
        }
        processingADCONRequest = false;

    }


    async Task<bool> isUserSelfAssignedEvaluator(UserModel user, UserModel potentialEvaluator)
    {
        if(user.selfAssignedEvaluators == null)
        {
            return false;
        }

        return user.selfAssignedEvaluators.Contains(potentialEvaluator.userID);
    }


    async Task<bool> isUserSuperiorAssignedEvaluator(UserModel user, UserModel potentialEvaluator)
    {
        if (user.superiorAssignedEvaluators == null)
        {
            return false;
        }

        return user.superiorAssignedEvaluators.Contains(potentialEvaluator.userID);
    }

    async Task makeSuperiorAssignedEvaluatorRequest()
    {
        processingSuperiorEvaluationRequest = true;
        UserModel potentialEvaluator = await userData.GetUserByEmail(superiorAssignedEvaluatorEmail);
        if(selectedUser.superiorAssignedEvaluators != null && selectedUser.superiorAssignedEvaluators.Count > 3) // TODO: change the 3 to a variable, not a hard coded number
        {
            Snackbar.Add($"ERROR: user has max number of superior assigned evaluators.", Severity.Error);
        }
        else if(potentialEvaluator == null)
        {
            Snackbar.Add($"ERROR: user with email ({superiorAssignedEvaluatorEmail}) not found", Severity.Error);
        }
        else if (await isUserSuperiorAssignedEvaluator(selectedUser, potentialEvaluator))
        {
            Snackbar.Add($"ERROR: {potentialEvaluator.firstName} is already a superior assigned evaluator", Severity.Error);
        }
        else if(await isUserSelfAssignedEvaluator(selectedUser, potentialEvaluator))
        {
            Snackbar.Add($"ERROR: {potentialEvaluator.firstName} was already assigned by {selectedUser.firstName} to be an evaluator", Severity.Error);
        }
        else
        {
            // TODO: update after Ethan sends new model. 
            RequestsModel newEvaluationAssignmentRequest = new RequestsModel();
            newEvaluationAssignmentRequest.requestInitiator = currentUser.userID;
            newEvaluationAssignmentRequest.requestTarget1 = potentialEvaluator.userID;
            newEvaluationAssignmentRequest.requestTarget2 = null;
            newEvaluationAssignmentRequest.value = selectedUser.userID;
            newEvaluationAssignmentRequest.type = "SuperiorAssignedEvaluationRequest";
            newEvaluationAssignmentRequest.status = "Pending";

            if (await requestsData.CheckIfRequestExist(newEvaluationAssignmentRequest))
            {
                Snackbar.Add("ERROR: request alread exist", Severity.Error);
            }
            else
            {
                Snackbar.Add("Request sent", Severity.Success);
                await requestsData.CreateRequests(newEvaluationAssignmentRequest);
            }
        }
        processingSuperiorEvaluationRequest = false;
    }


    async Task makeSelfAssignedEvaluatorRequest()
    {
        processingEvaluatorRequest = true;
        RequestsModel newEvaluationAssignmentRequest = new RequestsModel();
        newEvaluationAssignmentRequest.requestInitiator = currentUser.userID;
        newEvaluationAssignmentRequest.requestTarget1 = selectedUser.userID;
        newEvaluationAssignmentRequest.requestTarget2 = currentUser.superiors[0];

        if(newEvaluationAssignmentRequest.values == null)
        {
            newEvaluationAssignmentRequest.values = new List<string>();
        }
        newEvaluationAssignmentRequest.values.Add(selectedUser.userID);
        newEvaluationAssignmentRequest.values.Add(currentUser.userID);

        newEvaluationAssignmentRequest.type = "EvaluationAssignmentRequest";
        newEvaluationAssignmentRequest.status = "Pending";

        if (await requestsData.CheckIfRequestExist(newEvaluationAssignmentRequest))
        {
            Snackbar.Add("ERROR: request alread exist", Severity.Error);
        }
        else
        {
            Snackbar.Add("Request sent", Severity.Success);
            await requestsData.CreateRequests(newEvaluationAssignmentRequest);
        }
        processingEvaluatorRequest = false;
    }

    async Task removeSelfAssignedEvaluator()
    {
        await userData.removeSelfAssignedEvaluatorFromUser(selectedUser.userID, currentUser.userID);
        Snackbar.Add("Removed as evaluator. Refresh to see changes", Severity.Success);
        processingEvaluatorRequest = true;
    }

    async Task onRemoveSuperiorAssignedEvaluator(string evaluatorID, string userID)
    {
        await userData.removeSuperiorAssignedEvaluatorFromUser(evaluatorID, userID);
        Snackbar.Add("Removed as evaluator. Refresh to see changes", Severity.Success);
        var itemToRemove = superiorAssignedEvaluators.SingleOrDefault(r => r.userID == evaluatorID);
        if (itemToRemove != null)
        {
            superiorAssignedEvaluators.Remove(itemToRemove);
        }
    }

    IDictionary<string, int> roles = new Dictionary<string, int>() {
        { "HQ", 1 },
        { "Commander", 2 },
        { "Supervisor", 3 },
        { "Member", 4 },
    };

    // TODO: move this to data layer and rename to compareRoles
    bool isSuperiorToSelectedUser(string selectedUserRole)
    {
        if (selectedUserRole == "HQ" || selectedUserRole == "Commander" || selectedUserRole == "Supervisor" || selectedUserRole == "Member")
        {
            if (currentUser.role == "HQ" || currentUser.role == "Commander" || currentUser.role == "Supervisor" || currentUser.role == "Member")
            {
                if (roles[selectedUserRole] >= roles[currentUser.role] && currentUser.role != "Member")
                {
                    return true;
                }
            }
        }

        return false;
    }

    // TODO: move this to data layer
    bool doesUserHaveUnassignedRole(UserModel selectedUser)
    {
        return selectedUser.role == null;
    }

    // TODO: move this to data layer
    async Task updateSelectedUserRole(String newRole)
    {
        selectedUser.role = newRole;
        await userData.UpdateUser(selectedUser);
    }


    async Task<bool> assignOPCON(string userID, string teamID)
    {
        TeamsModel team = await teamsData.GetTeam(teamID);

        if(team.members == null) team.members = new List<string>();

        if (team.members.Contains(userID) == false)
        {
            UserModel user = await userData.GetUser(userID);

            if(user.teamIDs.Contains(team.ObjectId) == true)
            {
                return false;
            }

            team.members.Add(userID);
            user.teamIDs.Add(team.ObjectId);
            await userData.UpdateUser(user);
            await teamsData.UpdateTeam(team);
            return true;
        }
        return false;
    }

    async Task onOPCONAssignment(string userID, string teamID)
    {

        bool result = await assignOPCON(userID, teamID);

        if(result)
        {
            Snackbar.Add("Sucecssfully assigned OPCON", Severity.Success);
        }
        else
        {
            Snackbar.Add("ERROR: unable to assign OPCON", Severity.Error);
        }
    }


    async Task makeOPCONOutsourceRequest()
    {

        processingOPCONRequest = true;
        if (selectedTeam == null)
        {
            Snackbar.Add("ERROR: must select a valid team", Severity.Error);
        }
        RequestsModel newOPCONOutsourceRequest = new RequestsModel();
        newOPCONOutsourceRequest.requestTarget1 = selectedUser.superiors[0];
        newOPCONOutsourceRequest.requestTarget2 = selectedTeam.ObjectId; // TODO: update to account for supervisors being team leaders if Roger says so
        newOPCONOutsourceRequest.requestInitiator = selectedTeam.leader;
        newOPCONOutsourceRequest.value = selectedUser.userID;
        newOPCONOutsourceRequest.type = "OPCONOutsourceRequest";
        newOPCONOutsourceRequest.status = "Pending";


        if (await requestsData.CheckIfRequestExist(newOPCONOutsourceRequest))
        {
            Snackbar.Add("ERROR: request alread exist", Severity.Error);
        }
        else
        {
            await requestsData.CreateRequests(newOPCONOutsourceRequest);
            Snackbar.Add("Request sent", Severity.Success);

        }
        processingOPCONRequest = false;
    }


    protected async override Task OnInitializedAsync()
    {
        hasIndirectADCON = await userData.hasIndirectADCONOverUser(selectedUser, currentUser);
        hasDirectADCON = userData.hasDirectADCONOverUser(selectedUser, currentUser);
        hasOPCON = false; // TODO: update to see if they have OPCON over the selected user

        selectedIsSelfAssignedEvaluator = currentUser.selfAssignedEvaluators != null ? currentUser.selfAssignedEvaluators.Contains(selectedUser.userID) : false;
        selectedIsSuperiorAssignedEvaluator = currentUser.superiorAssignedEvaluators != null ? currentUser.superiorAssignedEvaluators.Contains(selectedUser.userID) : false;
        selectedIsEvaluatorOfCurrent = selectedIsSelfAssignedEvaluator || selectedIsSuperiorAssignedEvaluator;

        hasGreatORequalRole = isSuperiorToSelectedUser(selectedUser.role);
        selectedUserHasUnassignedRole = doesUserHaveUnassignedRole(selectedUser);
        isSameUser = selectedUser.userID == currentUser.userID;

        if (selectedUser.role == null)
        {
            roleAssignmentPrompt = "Assignment";
        }
        else
        {
            roleAssignmentPrompt = "Change";
        }

        if (selectedUser.superiors == null)
        {
            superiorName = "None";
        }
        else
        {
            if(selectedUser.superiors.Count > 0)
            {
                superior = await userData.GetUser(selectedUser?.superiors[0]);
                superiorName = superior?.firstName;
            }
            else
            {
                superiorName = "None";
            }

        }

        if(selectedUser.superiorAssignedEvaluators != null)
        {
            foreach (var evaluator in selectedUser.superiorAssignedEvaluators) 
            {
                superiorAssignedEvaluators.Add(await userData.GetUser(evaluator));
            }
            superiorAssignedEvaluators.RemoveAll(item => item == null);
        }

        //await userData.EmptyAllSupordinatesAndSuperiorsList();
        //await userData.EmptyAllEvaluators();
        //await userData.EmptyAllTeamIDs();
        //await teamsData.RemoveAllTeams();
        //await requestsData.RemoveAllRequests();

        //UserModel testUser = await userData.GetUserFromFirstName("Angela");
        //testUser.firstName = "Matthew";
        //testUser.lastName = "Jones";
        //await userData.UpdateUser(testUser);
    }
}
